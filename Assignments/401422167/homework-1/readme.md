# Homework 1

## 1
Thinking of divide and conquer, the first thing that comes
in mind is splitting the numbers in half. Assuming we have two
n-digits numbers `a` and `b`, we can split them into two halves.
let `m` be `floor(n/2)`.

```
  a_1 ... a_m | a_{m + 1} ... a_n
* b_1 ... b_m | b_{m + 1} ... b_n
_________________________________
...
```

We can now apply the technique mentioned in the homework. let
the left part of `a` be `al`, the right part `ar` and the same
with `bl` and `br`. Now we have

```
           al         ar
*          bl         br
___________________________
           al*br      ar*br
al*bl      ar*bl 
___________________________
al*bl  ar*bl + al*br  ar*br
...
```

But the time complexity of this algorithm is still `O(n^2)`.
It's not better than the last one. but with a little thinking
we can see that not all four smaller multiplications are
necessary, we can get the same result with computing only three
multiplications. Let
```
A := al*bl
B := ar*bl + al*br
C := ar*br
```

In order to calculate the values we can calculate the following

```
x = al*bl
y = ar*br
z = (al+ar)*(bl+br)
```

Then we have
```
A = x
B = z - x - y
C = y
```

The pseudocode of this algorithm would be as follows.

```
# It is assumed that a and b are of equal length.
0.  mul(a, b):
1.      let n := number of digits
            l := length of the left half (floor(n/2))
            r := length of the right half (n - l)
2.      if n == 1:
3.          return a * b
4.      let al and ar be the left and right halves of a      (divide)
5.      let bl and br be the left and right halves of b      (divide)
6.      let x be mul(al, bl)                                 (conquer)
7.      let y be mul(ar, br)                                 (conquer)
8.      let z be mul(al+ar, bl+br)                           (conquer)
9.      return x * 10 ** (2 * r) + (z - x - y) * 10 ** r + y (combine)
```

The divide, conquer, and combine steps are marked above.

## 2
The smallest sub-problem in this method would be the line number
`3`, the multiplication of two digits.

## 3
The script can be found in the file [main.py](main.py).

```bash
python3 main.py 1234 5678
```

## 4
Assuming the time of multiplication of two digits is `1`, we can say that
the time for two numbers of length `n` would be `3^(n/2)` because we
divide the problem of length `n` into three sub-problems of length `n/2`.

```
T(1) = 1
T(n) = 3^(n/2)
```

By solving this we get to `O(n ^ (log_2(3)))`. `log_2(3)` is near to
`O(n ^ 1.5849625007)` being less than `2`, which means this algorithm
works better than `O(n ^ 2)`.

## Testing
Using another file [test.py](test.py), we can see the performance by
generating two large numbers and running both our algorithm and python's
`*` operator on them.

```bash
python3 test.py 2048
```

This will create two random numbers of length 2048 digits, runs both
methods, and reports the results. The output would be

```
a = 24734903685311957016894309512690671723649720870747160496453870932356145812407647663445138207220457680652865125420000060059477537849836653165658601899066735509504710892581274165911955403035184307557632899289411626301820351982307403325838252710889734942183782497119075212493858825170750212087713905998422623074565890569526139713086302633526466805632834148986995886995553491727058511326302661042010099082523394602222690210410251077302212798829856818099766880098397565012862414014242571468323015397370423488076305376993440500162850331364376469441710300091069087192591644609645223498540498766024465400291475829442276559908085415169545970291217386041594373886592910793383271512624685724240944169374762146745206101330391985538281404580926382375892330048158408607615692001916731383885590812502512819294785386810779777351002118401305405179724274579463890135924532520119474680307082917947873822024431102994902346324133595484640893620083278312798274290356255038527667765887924669342006115687926667627417565909992539149511126509130978794454953663416813472260089123999757625252896143720471638282604367277105110467751932812759916324965868661036057685647725736716751350863893472527696405693172151455861611658329059139938738914715808453576667069429975115135617850286542095390102276032375180100707093386976363851409711676347149663034944116602658481527224955184843510299002968753003731371467032162307591894555632841642134275755079167136403405098721770414440440160424213879937478617232332314205588295550481873563966866634325219320579996716894307488788132329990532483226511262551500986730246271664254395630318042481755461290908297702837442421712541710683747072511745655513158873203798833215295152130338667666737042630887889412290484531938148122326260948652258953982431893773348131551655641726060365568941175611062101290813743475672367833250272929467991368150993870399239818694302758064928438726895626802787210777926055015937656475016192304527317496557277863874258194741645084165727111828662404722339189206678412122583608633578641543124616196704521912760381223659410069
b = 08975413609088266555228148672789654269514060679363759870711439736515588944483463853621663483960444760316368532670288616720967857540934494010600154598072304179740725227714056250635332715396170483858570122388571585169759415227324773410835462029226266339165371985761929207042203191494395635187038337597262717992871516987843543079714605242627323002783556716573388389746273529970112641507923576373841784160578637247026928310453058904555917880451242323669767203972389042047837939493338371750969395548632018089759649437763625178941766497551535791110907798527534491883375608849774375407483196647751361113648082928932243032354402714451006357309648699627157599985838499630456883315338331492619360975851946057893848045544699414888908114144287044751055920259171677611281246304087175921143242373469191534086745565981889550327370381441786932571776187784306373066200792720672610780525912571661681826236643959697024307549639758042796998478296176437435581053514264796265335702729192941144928374114601511544988899259202597167054690284020095066741041054311174637673291320829214460216485417091742818779471413340533300585382559173894970376479436183653510459168480507523933283527559151838001979223094311871715034686320018550325441662275731716495404206539745800529611849975486929296906970871495396263134299100322549641708419005983918032773964054831178944454929018973446832187805995105890896697156551443015005818867270486992862594496573276759400211974121976569644347037237809777465829193066429148240986799102077019850954842197152718633773412573343047329451181385208011654859567192226593929392717132283625310560403521022211391084530875554000152419315543557029573522358140450911156055556708403209911157587875303752884702265473213239201911658641249846734050729758059425320387699913069748211570508428365126050264195978643714457380045166576692147057638517368079566386033831685162329158774038010116756576754280600143235274860174176514533675531870871647987084847556561020671693462382875054340785703794782978585806438505379237269078918367159057318766496272495772820360989699668896

python took: 26682ns
mul took: 361871089ns
```

As seen above the python's multiplication is a lot better. This can have
many reasons. We do the multiplications digit-by-digit but Python may use
the CPU's ability to multiply two multi-digit numbers in one operation,
also we did a lot of string to int and int to string casts which would
take time. And also, Python's interpreter probably uses the best practical
algorithms found till now, and does a lot of optimizations.
