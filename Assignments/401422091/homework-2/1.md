### 1.1.

<p dir="rtl">
در رویکرد غیرهوشمندانه میتونیم در یک حلقه به اندازه ی لیست امتیازها، الگوریتم بهترین انتخاب در زیر مجموعه رو انجام بدیم. به این صورت که یه زیر مجموعه داریم و هر بار میتونیم از ابتدا یا انتهاش رو برداریم. و همچنین حریف هم میتونه از ابتدا یا انتهاش یه امتیاز برداره. بعد از هر کدوم از این ۴ حالت، باید یه تابع بازگشتی صدا زده بشه و برای هر کدوم از اون زیر مجموعه ها هم این محاسبات رو انجام بده و مسیر و امتیازی که بدست آوردیم رو هم ذخیره کنه که در انتها بتونیم بیشترین امتیاز رو برداریم و مسیر رسیدن به اون رو هم چاپ کنیم. منظورم از مسیر اینه که چه حرکت هایی برای رسیدن به اون مسیر باید انجام بدیم.
همچنین جایی که الگوریتم باید متوقف بشه رو هم باید بذاریم وقتی که ۲ تا مهره داریم و در این حالت فقط یک حالت داریم اون هم اینکه بزرگترین امتیاز رو برداریم.
در این الگوریتم تمام حالت های ممکن رو بدست میاریم و بیشترین امتیاز رو از بین شون انتخاب میکنیم.
</p>

### 1.2.

<p dir="rtl">
با استفاده از برنامه نویسی پویا میشه خیلی در با پیچیدگی زمانی بهتری به این مسئله جواب داد. ایده اصلی هم اینه که اول برنامه رو به زیر مسئله های کوچیکتر تقسیم کنیم و بعد به راه حل اصلی برسیم. راه حل کلی اینه که یه آرایه ی دو بعدی داشته باشیم که در هر خونه i و j امش بیشترین امتیازی که میتونیم از ورودی i و j ام بگیریم رو ذخیره کنیم. یعنی برای رسیدن به جواب کلی مسئله فقط نیازه که به جای i بذاریم 0 و به جای j هم طول ورودی منهای یک رو بذاریم. در اون خونه، ما جواب کلی مسئله رو داریم.  در ابتدا همه ی خونه های این آرایه ی دو بعدی رو با 0 پر میکنیم و بعد توی یه حلقه در نظر میگیریم که اگر بازیکن مهره ی راست و یا چپ رو برداره، چه امتیازی میگیره و با یه ماکزیمم گیری، حرکت بهینه رو انتخاب میکنیم. فقط در این مسئله در نظر گرفته شده که بازیکن حریف هم بهینه بازی میکنه. یعنی در نهایت عددی که در جواب میگیریم، عددی هست که بهینه هست با توجه به بهینه بازی کردن حریف و در صورتی که حریف بهینه بازی نکنه، حتی میشه امتیاز بیشتری هم گرفت.
</p>


### 1.3.
<p dir="rtl">
پیچیدگی زمانی این الگوریتم با توجه به دو حلقه ای که استفاده میشه، برابر با o(n^2) است. البته این فقط برای محاسبه عدد بیشترین امتیاز هست و برای بدست آورد ترتیب حرکت ها هم نیاز به o(n) هست.
</p>
