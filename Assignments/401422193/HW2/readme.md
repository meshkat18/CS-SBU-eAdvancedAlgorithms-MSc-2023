**به نام یگانه برنامه نویس عالم**<br>
الگوریتم های پیشرفته<br>
استاد فراهانی
# [تمرین 2](https://github.com/Sarach-git/CS-SBU-eAdvancedAlgorithms-MSc-2023/blob/main/Assignments/Homework/Homework_2.pdf)
دستیار آموزشی:     سرکار خانم چرمچی<br>
کد ، نام دانشجو:     (401422193 ، معین ورکیانی)

---

## سوال 1

### بخش 1

در رویکرد غیر هوشمندانه، ما نیاز به بررسی تمامی حالت های ممکن داریم؛ در نتیجه با توجه به اینکه تعداد انتخاب ها (نوبت ها) برابر با تعداد مهره ها است و در هر نوبت هر شخص دو گزینه متفاوت دارد و در مجموع 4 حالت ممکن ست پیش بیاید، نیازمند فراخوانی بازگشتی خواهیم بود تا پاسخ هر شیوه انتخاب مهره ها را محاسبه کرده و ذخیره کنیم. در نهایت با جستجو بر روی مقادیر پاسخ ها، بهترین پاسخ را میابیم. با توجه به اینکه در هر نوبت دو حالت برای انتخاب وجود دارد، پیچیدگی زمانی الگوریتم از مرتبه $O(2^n)$ خواهد بود.
  
### بخش 2

با توجه به اینکه هر بازیکن در نوبت خود به صورت بهینه باید انتخاب کند، حریف هموار انتخاب هایی خواهد کرد که در نوبت ما، حداقل امتیاز را کسب کنیم. دو انتخاب وجود دارد:
  
1. کاربر سکه `i`ام را با مقدار $V_i$ انتخاب می کند: حریف یا `(i+1)`مین سکه یا سکه `j`ام را انتخاب می کند. حریف قصد دارد سکه ای را انتخاب کند که حداقل ارزش را برای کاربر باقی می گذارد. به عنوان مثال، کاربر می تواند مقدار $V_i + min (F(i+2, j), F(i+1, j-1))$ را جمع آوری کند که در آن `[i+2,j]` ایندکس آرایه در دسترس کاربر است اگر حریف $V_{i+1}$ را انتخاب می کند و `[i+1,j-1]` محدوده ایندکس‌های آرایه در دسترس است اگر حریف سکه `j`ام را انتخاب کند.<br><br>
2. کاربر سکه `j`ام را با مقدار $V_j$ انتخاب می کند: حریف یا سکه `i`ام یا `j-1`ام را انتخاب می کند. حریف قصد دارد سکه‌ای را انتخاب کند که حداقل مقدار را برای کاربر باقی می‌گذارد، یعنی کاربر می‌تواند مقدار $V_j + min(F(i+1, j-1), F(i, j-2))$ را در جایی جمع‌آوری کند که `[i,j-2]` محدوده ایندکس‌های آرایه‌ای است که در صورتی که حریف سکه `j`ام را انتخاب کند برای کاربر در دسترس است و `[i+1,j-1]`محدوده ایندکس‌هایی است که در صورتی که حریف سکه `i`ام را انتخاب کند در دسترس کاربر است.
    
از آنجایی که همان زیر-مسائل مجددا فراخوانی می شوند، این مشکل دارای ویژگی همپوشانی زیر-مسائل است. بنابراین می توان با ساختن یک آرایه موقت در برنامه نویسی پویا به روش پایین به بالا با استفاده از فرمول بازگشتی زیر از محاسبات مجدد همان مسائل فرعی اجتناب کرد.
  
### بخش 3

الگوریتم با پر کردن یک جدول با پاسخ های بهینه برای مسائل فرعی کوچکتر کار می کند. به عنوان مثال، اگر روی زیرآرایه ای کار می کنیم که فقط یک مهره دارد، پاسخ بهینه امتیاز آن مهره است. اگر روی زیرآرایه ای کار می کنیم که دو مهره دارد، پاسخ بهینه، حداکثر مقدار دو مهره است. ما زیرآرایه ها را گسترش می دهیم و از نتایج مسائل فرعی کوچکتر برای ساختن پاسخ بهینه برای مسائل فرعی بزرگتر استفاده می کنیم. در نهایت، پاسخ بهینه برای کل آرایه (`n*n`) در سطر اول و آخرین ستون جدول ذخیره می شود. در نتیجه پیچیدگی زمانی این الگورتم از مرتبه $O(n^2)$ خواهد بود.

### **بخش 4: پیاده سازی در پایتون**
```python
#Function to find the maximum possible score we can win.
class Solution:
  def GamePlan(self,arr, n):
    temp=[[0 for i in range(n)]for j in range(n)]
    moves=[["" for i in range(n)]for j in range(n)]
    def solve(ind1,ind2):
        if ind1>ind2:
            return 0, ""
        if (temp[ind1][ind2]!=-1)&(moves[ind1][ind2]!=""):
            return temp[ind1][ind2],moves[ind1][ind2]
        if ind1==ind2:
            moves[ind1][ind2]+="L" if ind1<=(n-1)//2 else "R"
            return arr[ind1],moves[ind1][ind2]
        take_start=arr[ind1]
        score1, move11=solve(ind1+2,ind2)
        score2, move12=solve(ind1+1,ind2-1)
        if score1+arr[ind1]>score2+arr[ind2]:
            take_start+=score2
            move11=f"R{move12}"
        else:
            take_start+=score1
            move11=f"L{move11}"
        take_last=arr[ind2]
        score1, move21=solve(ind1+1,ind2-1)
        score2, move22=solve(ind1,ind2-2)
        if score1+arr[ind2]>score2+arr[ind1]:
            take_last+=score2
            move21=f"R{move22}"
        else:
            take_last+=score1
            move21=f"L{move21}"
            
        if take_start>take_last:
            ans= take_start
            moves[ind1][ind2]=f"L{move11}"
        else:
            ans=take_last
            moves[ind1][ind2]=f"R{move21}"
        temp[ind1][ind2]=ans
        return ans, moves[ind1][ind2]    
    res,moves = solve(0,n-1)
    return res,moves

def main():
    beads = list(map(int, input().split()))
    ans=Solution()
    score, moves=ans.GamePlan(beads,len(beads))
    print(score, moves)
    
if __name__ == "__main__":
    main()
```

---
## سوال 2

### داده ها
    
- حداکثر مسافتی که خودرو با باک پر می تواند طی کند: `n`
- لیستی از شهرهای مسیر تبریز به زاهدان: `cities`

### توضیح الگوریتم    
    
1. متغیر `Current_position` را در شهر شروع (تبریز) مقداردهی کنید و به لیست خالی `refill_stops` وارد کنید.
2. تا زمانی که `Current_position` با شهر مقصد زاهدان برابر نیست، موارد زیر را انجام دهید:
    - فرض کنید `farthest_city` شهر قبلی در لیست باشد که از موقعیت فعلی بدون پر کردن مخزن قابل دسترسی است، یعنی دورترین `city` در `cities` به طوری که فاصله بین `Current_position` و شهر کمتر یا مساوی `n` باشد.
    - اگر `farthest_city`=`None` باشد، خودرو نمی تواند به شهر مقصد برسد و الگوریتم خاتمه می یابد.
    - در غیر این صورت `farthest_city` را به `refill_stops` اضافه کنید و `Current_position` را روی `farthest_city` قرار دهید
3. `refill_stops` را بازگردانید.


فرض کنید $P$ موقعیت فعلی، $x$ و $y$ دو شهر متوالی در لیست شهرها و $d(x, y)$ فاصله بین $x$ و $y$ باشد و $f(x)$ دورترین شهر قابل دسترسی از $x$ بدون پر کردن مخزن باشد، یعنی دورترین شهر در شهرها به طوری که فاصله بین $x$ و شهر کمتر یا مساوی $n$ باشد.

- قضیه: پر کردن مخزن در شهر $y$ بدتر از پر کردن مجدد آن در شهر $x$ نیست.
- اثبات: 
1. فرض کنید در شهر $P$ هستیم و باید از طریق شهرهای $x$ و $y$ از $P$ به زاهدان سفر کنیم. فرض کنید $P'$ موقعیتی باشد که پس از پر کردن مخزن در شهر $x$ به آن می‌رسیم. سپس داریم:<br>
 + $d(P, x) <= n$: می توانیم از $P$ به $x$ بدون پر کردن مجدد مخزن حرکت کنیم<br>
 + $d(x,y) <= n$: می توانیم از $x$ به $y$ بدون پر کردن مجدد مخزن سفر کنیم<br>
 + $d(y, P') <= n$: می توانیم از $y$ به $P'$ بدون پر کردن مجدد مخزن سفر کنیم
2. از سوی دیگر، اگر مخزن را در شهر $y$ دوباره پر کنیم، می‌توانیم از $P$ به $y$ بدون پر کردن مجدد سفر کنیم و $f(y)$ دورترین شهری است که می‌توانیم از $y$ بدون پر کردن مجدد به آن برسیم. بنابراین، داریم:
 + $d(P, x) + d(x, y) + d(y, P') <= 3n$
 + $d(P, y) + d(y, f(y)) <= 2n$
 + $d(P, y) <= d(P, x) + d(x, y)$ و $f(y) <= P'$ 
 + $d(P, y) + d(y, f(y)) <= d(P, x) + d(x, y) + d(y, P')$
    
بنابراین، پر کردن مخزن در شهر $y$ بدتر از پر کردن مجدد آن در شهر $x$ نیست. این امر اثبات را کامل می کند و رویکرد حریصانه انتخاب دورترین شهر قابل دسترس در هر مرحله از الگوریتم را توجیه می کند.

---
## سوال 3

برای حل این مسئله، می‌توان از الگوریتم فلویید-وارشال (`Floyd-Warshall`) استفاده کرد. در این الگوریتم، ابتدا یک ماتریس فاصله‌ها ایجاد می‌شود که در ابتدا، مقدار بین هر دو شهر برابر با فاصله بین آن دو شهر است. سپس در هر مرحله، تمامی مسیرهای ممکن برای رسیدن به شهرهای مختلف ترکیب و با مسیرهای دیگری که قبلاً به دست آمده‌اند، مقایسه می‌شوند. به این صورت که اگر مسیر جدید کوتاه‌تر از مسیر قبلی بین دو شهر باشد، مقدار ماتریس فاصله به روزرسانی می‌شود. بعد از اتمام این مراحل، ماتریس فاصله‌های کوتاه‌ترین مسیرها بین هر دو شهر به دست می‌آید.

### پیاده سازی در پایتون    

در کد پایتون زیر، این الگوریتم با استفاده از ماتریس فاصله‌ها (dist) پیاده‌سازی شده است. خروجی نهایی مقدار مجموع حداقل فاصله بین هر دو شهر را در مبنای 10 و 2 نمایش می‌دهد:
```python
import pandas as pd

INF = float('inf')

def MinDist(n, dist):
    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    return dist

n, m = map(int, input().split())
dist = [[INF for _ in range(n)] for _ in range(n)]

for _ in range(m):
    u, v, w = map(int, input().split())
    dist[u-1][v-1] = dist[v-1][u-1] = 2 ** w

distances = MinDist(n, dist)
total_dist = 0
for i in range(n):
    for j in range(i + 1, n):
        total_dist += distances[i][j]
print("{0:b}".format(total_dist))
```

---

## سوال 4

برای حل این مشکل، می‌توانیم چندین شرط را بررسی کنیم تا مشخص شود که آیا ممکن است سارقان بدون دستگیر شدن، سرقت‌های خود را تکمیل کنند یا خیر. می توانیم از دستور if برای بررسی شرایط زیر استفاده کنیم:

- بررسی کنید که آیا تعداد سارقان، N، بیشتر از 2 برابر زمان غیبت نگهبان، G، است. اگر چنین است، امکان ندارد بیش از 2 سارق در طول G دقیقه داخل سالن باشند.
- بررسی کنید که آیا دزدی وجود دارد که به زمان بیشتری از زمان غیبت نگهبان نیاز دارد یا خیر.
- بررسی کنید که آیا حداکثر زمان مورد نیاز در بین سارقان کمتر یا مساوی با زمان غیبت نگهبان G و تعداد سارقان کمتر یا مساوی 2 است. اگر هر دو شرط برآورده شود، همه سارقان می توانند سرقت های خود را در غیاب نگهبان انجام دهند.
    
در صورت احراز هیچ یک از شرایط فوق، می توان دستور سرقتی را داشت که شرایط داده شده را داشته باشد.
```python
def Success(N, G, A):
    max_time = max(A)
    if max_time <= G and N <= 2:
        return "YES"
    if N > 2 * (G + 1):
        return "NO"
    if max_time > G:
        return "NO"
    return "YES"

thefts = int(input())
result = []

for _ in range(thefts):
    N, G = map(int, input().split())
    A = list(map(int, input().split()))
    result.append(Success(N, G, A))

for i in range(len(result)):
    print(result[i])
```
