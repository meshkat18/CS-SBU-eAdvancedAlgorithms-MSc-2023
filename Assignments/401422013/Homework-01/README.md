<div dir=rtl>

# تمرین اول

1 - پیچیدگی زمانی الگوریتم تقسیم و غلبه O(n^log3) می‌باشد که نسب به روش بالا که O(n^2) هست، بهتر هست. 

شبه کد:

<pre dir=ltr>
Algorithm Multiply(a, b):
    // Conquer
    if |a| == 1 or |b| == 1 then
        return  A * B
    else
        // Split
        n ← max(|A|, |B|)
        xL, xR ← Split(A, n)
        yL, yR ← Split(B, n)

        // Combine
        z0 ← multiply(xL, yL)
        z1 ← multiply(xL + xR, yR + yL)
        z2 ← multiply(xR, yR)
        return z2 * 10^(2*m) + (z1 - z2 - z0) * 10^m + z0
    end
</pre>

<div dir=rtl>
مسئله را به دو زیر مسئله کوچکتر تبدیل میکنیم. اینکار را با استفاده از جدا کردن هر عدد به دو بخش انجام میدهیم. سپس اینکار را به صورت بازگشتی به زیر مسئله‌های کوچکتر تبدیل میکنیم. در نهاییت زمانی که زیرمسئله ها به نتیجه رسیند، آنها را ترکیب میکنیم.
مراحل با استفاده از کامنت در شبه کد مشخص شده است.

2 - زمانی که a و b تک رقم هستند، زیرا نیازی به فرایند بازگشتی نیست و مستقیم جواب میدهند.

3 - روشی که در سوال مطرح شده است به صورت O(n^2) میباشد. و روشی که به صورت تقسیم و غلبه میباشد به صورت O(n^log3) میباشد.

T(n) = 3T(n/2) + O(n^log2(3))
<br />
T(n) = O(n^log2(3))


<hr />
برای اجرای تست میتوانید از دستور `python -m unittest test.py` در ترمینال استفاده نمایید.
